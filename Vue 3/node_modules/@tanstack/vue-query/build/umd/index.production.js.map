{"version":3,"file":"index.production.js","sources":["../../../query-core/build/lib/subscribable.mjs","../../../query-core/build/lib/utils.mjs","../../../query-core/build/lib/focusManager.mjs","../../../query-core/build/lib/onlineManager.mjs","../../../query-core/build/lib/retryer.mjs","../../../query-core/build/lib/logger.mjs","../../../query-core/build/lib/notifyManager.mjs","../../../query-core/build/lib/removable.mjs","../../../query-core/build/lib/query.mjs","../../../query-core/build/lib/queryCache.mjs","../../../query-core/build/lib/mutation.mjs","../../../query-core/build/lib/mutationCache.mjs","../../../query-core/build/lib/infiniteQueryBehavior.mjs","../../../query-core/build/lib/queryObserver.mjs","../../../query-core/build/lib/queriesObserver.mjs","../../../query-core/build/lib/infiniteQueryObserver.mjs","../../../query-core/build/lib/mutationObserver.mjs","../../../query-core/build/lib/hydration.mjs","../../src/utils.ts","../../src/useQueryClient.ts","../../src/queryCache.ts","../../src/mutationCache.ts","../../src/queryClient.ts","../../../query-core/build/lib/queryClient.mjs","../../src/vueQueryPlugin.ts","../../src/useBaseQuery.ts","../../src/useInfiniteQuery.ts","../../src/useIsFetching.ts","../../src/useIsMutating.ts","../../src/useMutation.ts","../../src/useQueries.ts","../../src/useQuery.ts"],"sourcesContent":["class Subscribable {\n  constructor() {\n    this.listeners = new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    const identity = {\n      listener\n    };\n    this.listeners.add(identity);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(identity);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.mjs.map\n","// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    const changed = this.focused !== focused;\n\n    if (changed) {\n      this.focused = focused;\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nexport { FocusManager, focusManager };\n//# sourceMappingURL=focusManager.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nconst onlineEvents = ['online', 'offline'];\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        onlineEvents.forEach(event => {\n          window.addEventListener(event, listener, false);\n        });\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach(event => {\n            window.removeEventListener(event, listener);\n          });\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    const changed = this.online !== online;\n\n    if (changed) {\n      this.online = online;\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nexport { OnlineManager, onlineManager };\n//# sourceMappingURL=onlineManager.mjs.map\n","import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n\n        if (canContinue) {\n          continueResolve(value);\n        }\n\n        return canContinue;\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.mjs.map\n","const defaultLogger = console;\n\nexport { defaultLogger };\n//# sourceMappingURL=logger.mjs.map\n","import { scheduleMicrotask } from './utils.mjs';\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.mjs.map\n","import { isValidTimeout, isServer } from './utils.mjs';\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\nexport { Removable };\n//# sourceMappingURL=removable.mjs.map\n","import { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\"Missing queryFn for queryKey '\" + this.options.queryHash + \"'\");\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + this.queryHash);\n          }\n\n          onError(new Error(this.queryHash + \" data is undefined\"));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);\n        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasData = typeof data !== 'undefined';\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\nexport { Query };\n//# sourceMappingURL=query.mjs.map\n","import { hashQueryKeyByOptions, parseFilterArgs, matchQuery } from './utils.mjs';\nimport { Query } from './query.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\nexport { QueryCache };\n//# sourceMappingURL=queryCache.mjs.map\n","import { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Removable } from './removable.mjs';\nimport { createRetryer, canFetch } from './retryer.mjs';\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.defaultOptions = config.defaultOptions;\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    var _this$retryer$continu, _this$retryer;\n\n    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({\n            type: 'failed',\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context)); // Notify cache callback\n\n      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context)); // Notify cache callback\n\n        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, undefined, error, this.state.variables, this.state.context, this));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\nexport { Mutation, getDefaultState };\n//# sourceMappingURL=mutation.mjs.map\n","import { notifyManager } from './notifyManager.mjs';\nimport { Mutation } from './mutation.mjs';\nimport { matchMutation, noop } from './utils.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    var _this$resuming;\n\n    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {\n      const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n    }).then(() => {\n      this.resuming = undefined;\n    });\n    return this.resuming;\n  }\n\n}\n\nexport { MutationCache };\n//# sourceMappingURL=mutationCache.mjs.map\n","function infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject(\"Missing queryFn for queryKey '\" + context.options.queryHash + \"'\"));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n","import { shallowEqualObjects, noop, isServer, isValidTimeout, timeUntilStale, replaceData } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { canFetch, isCancelledError } from './retryer.mjs';\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (process.env.NODE_ENV !== 'production' && typeof (options == null ? void 0 : options.isDataEqual) !== 'undefined') {\n      this.client.getLogger().error(\"The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option\");\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    const result = this.createResult(query, options);\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result;\n      this.currentResultOptions = this.options;\n      this.currentResultState = this.currentQuery.state;\n    }\n\n    return result;\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const isLoading = status === 'loading';\n    const isError = status === 'error';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === 'function' ? notifyOnChangeProps() : notifyOnChangeProps;\n\n      if (notifyOnChangePropsValue === 'all' || !notifyOnChangePropsValue && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n} // this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\n\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false;\n  } // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n\n\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData;\n  } // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n\n\n  if (observer.getCurrentResult() !== optimisticResult) {\n    return true;\n  } // basically, just keep previous properties if nothing changed\n\n\n  return false;\n}\n\nexport { QueryObserver };\n//# sourceMappingURL=queryObserver.mjs.map\n","import { difference, replaceAt } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { QueryObserver } from './queryObserver.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getQueries() {\n    return this.observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getObservers() {\n    return this.observers;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\n    const matchingObserversSet = new Set(matchingObservers.map(match => match.observer));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObserversSet.has(prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nexport { QueriesObserver };\n//# sourceMappingURL=queriesObserver.mjs.map\n","import { QueryObserver } from './queryObserver.mjs';\nimport { infiniteQueryBehavior, hasNextPage, hasPreviousPage } from './infiniteQueryBehavior.mjs';\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    const {\n      isFetching,\n      isRefetching\n    } = result;\n    const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward';\n    const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward';\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n  }\n\n}\n\nexport { InfiniteQueryObserver };\n//# sourceMappingURL=infiniteQueryObserver.mjs.map\n","import { getDefaultState } from './mutation.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { shallowEqualObjects } from './utils.mjs';\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    var _this$currentMutation;\n\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n\n    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$currentMutation2;\n\n      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\nexport { MutationObserver };\n//# sourceMappingURL=mutationObserver.mjs.map\n","// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Reset fetch status to idle in the dehydrated state to avoid\n    // query being stuck in fetching state upon hydration\n\n    const dehydratedQueryState = { ...dehydratedQuery.state,\n      fetchStatus: 'idle'\n    }; // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {\n        query.setState(dehydratedQueryState);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQueryState);\n  });\n}\n\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };\n//# sourceMappingURL=hydration.mjs.map\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { isRef, unref } from 'vue-demi'\nimport type { MutationKey, QueryKey } from '@tanstack/query-core'\nimport type { UnwrapRef } from 'vue-demi'\n\nexport const VUE_QUERY_CLIENT = 'VUE_QUERY_CLIENT'\n\nexport function getClientKey(key?: string) {\n  const suffix = key ? `:${key}` : ''\n  return `${VUE_QUERY_CLIENT}${suffix}`\n}\n\nexport function isQueryKey(value: unknown): value is QueryKey {\n  return Array.isArray(value)\n}\n\nexport function isMutationKey(value: unknown): value is MutationKey {\n  return Array.isArray(value)\n}\n\nexport function updateState(\n  state: Record<string, unknown>,\n  update: Record<string, any>,\n): void {\n  Object.keys(state).forEach((key) => {\n    state[key] = update[key]\n  })\n}\n\nexport function cloneDeep<T>(\n  value: T,\n  customizer?: (val: unknown) => unknown | void,\n): T {\n  if (customizer) {\n    const result = customizer(value)\n    if (result !== undefined || isRef(value)) {\n      return result as typeof value\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((val) => cloneDeep(val, customizer)) as typeof value\n  }\n\n  if (typeof value === 'object' && isPlainObject(value)) {\n    const entries = Object.entries(value).map(([key, val]) => [\n      key,\n      cloneDeep(val, customizer),\n    ])\n    return Object.fromEntries(entries)\n  }\n\n  return value\n}\n\nexport function cloneDeepUnref<T>(obj: T): UnwrapRef<T> {\n  return cloneDeep(obj, (val) => {\n    if (isRef(val)) {\n      return cloneDeepUnref(unref(val))\n    }\n  }) as UnwrapRef<typeof obj>\n}\n\nfunction isPlainObject(value: unknown): value is Object {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n","import { getCurrentInstance, inject } from 'vue-demi'\n\nimport { getClientKey } from './utils'\nimport type { QueryClient } from './queryClient'\n\nexport function useQueryClient(id = ''): QueryClient {\n  const vm = getCurrentInstance()?.proxy\n\n  if (!vm) {\n    throw new Error('vue-query hooks can only be used inside setup() function.')\n  }\n\n  const key = getClientKey(id)\n  const queryClient = inject<QueryClient>(key)\n\n  if (!queryClient) {\n    throw new Error(\n      \"No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.\",\n    )\n  }\n\n  return queryClient\n}\n","import { QueryCache as QC } from '@tanstack/query-core'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport type { Query, QueryFilters, QueryKey } from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\n\nexport class QueryCache extends QC {\n  find<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData>(\n    arg1: MaybeRefDeep<QueryKey>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2) as QueryFilters\n    return super.find(arg1Unreffed, arg2Unreffed)\n  }\n\n  findAll(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): Query[]\n  findAll(filters?: MaybeRefDeep<QueryFilters>): Query[]\n  findAll(\n    arg1?: MaybeRefDeep<QueryKey | QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): Query[]\n  findAll(\n    arg1?: MaybeRefDeep<QueryKey> | MaybeRefDeep<QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): Query[] {\n    const arg1Unreffed = cloneDeepUnref(arg1) as QueryKey | QueryFilters\n    const arg2Unreffed = cloneDeepUnref(arg2) as QueryFilters\n    if (isQueryKey(arg1Unreffed)) {\n      return super.findAll(arg1Unreffed, arg2Unreffed)\n    }\n    return super.findAll(arg1Unreffed)\n  }\n}\n","import { MutationCache as MC } from '@tanstack/query-core'\nimport { cloneDeepUnref } from './utils'\nimport type { Mutation, MutationFilters } from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\n\nexport class MutationCache extends MC {\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MaybeRefDeep<MutationFilters>,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    return super.find(cloneDeepUnref(filters) as MutationFilters)\n  }\n\n  findAll(filters: MaybeRefDeep<MutationFilters>): Mutation[] {\n    return super.findAll(cloneDeepUnref(filters) as MutationFilters)\n  }\n}\n","import { ref } from 'vue-demi'\nimport { QueryClient as QC } from '@tanstack/query-core'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport type { MaybeRefDeep } from './types'\nimport type {\n  CancelOptions,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationFilters,\n  MutationKey,\n  MutationObserverOptions,\n  QueryClientConfig,\n  QueryFilters,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryState,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n  Updater,\n} from '@tanstack/query-core'\n\nexport class QueryClient extends QC {\n  constructor(config: MaybeRefDeep<QueryClientConfig> = {}) {\n    const unreffedConfig = cloneDeepUnref(config) as QueryClientConfig\n    const vueQueryConfig: QueryClientConfig = {\n      logger: cloneDeepUnref(unreffedConfig.logger),\n      defaultOptions: cloneDeepUnref(unreffedConfig.defaultOptions),\n      queryCache: unreffedConfig.queryCache || new QueryCache(),\n      mutationCache: unreffedConfig.mutationCache || new MutationCache(),\n    }\n    super(vueQueryConfig)\n  }\n\n  isRestoring = ref(false)\n\n  isFetching(filters?: MaybeRefDeep<QueryFilters>): number\n  isFetching(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): number\n  isFetching(\n    arg1?: MaybeRefDeep<QueryFilters | QueryKey>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): number {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2) as QueryFilters\n    if (isQueryKey(arg1Unreffed)) {\n      return super.isFetching(arg1Unreffed, arg2Unreffed)\n    }\n    return super.isFetching(arg1Unreffed as QueryFilters)\n  }\n\n  isMutating(filters?: MaybeRefDeep<MutationFilters>): number {\n    return super.isMutating(cloneDeepUnref(filters) as MutationFilters)\n  }\n\n  getQueryData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): TData | undefined {\n    return super.getQueryData(\n      cloneDeepUnref(queryKey),\n      cloneDeepUnref(filters) as QueryFilters,\n    )\n  }\n\n  getQueriesData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): [QueryKey, TData | undefined][]\n  getQueriesData<TData = unknown>(\n    filters: MaybeRefDeep<QueryFilters>,\n  ): [QueryKey, TData | undefined][]\n  getQueriesData<TData = unknown>(\n    queryKeyOrFilters: MaybeRefDeep<QueryKey> | MaybeRefDeep<QueryFilters>,\n  ): [QueryKey, TData | undefined][] {\n    const unreffed = cloneDeepUnref(queryKeyOrFilters)\n    if (isQueryKey(unreffed)) {\n      return super.getQueriesData(unreffed)\n    }\n    return super.getQueriesData(unreffed as QueryFilters)\n  }\n\n  setQueryData<TData>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): TData | undefined {\n    return super.setQueryData(\n      cloneDeepUnref(queryKey),\n      updater,\n      cloneDeepUnref(options) as SetDataOptions,\n    )\n  }\n\n  setQueriesData<TData>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): [QueryKey, TData | undefined][]\n  setQueriesData<TData>(\n    filters: MaybeRefDeep<QueryFilters>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): [QueryKey, TData | undefined][]\n  setQueriesData<TData>(\n    queryKeyOrFilters: MaybeRefDeep<QueryKey | QueryFilters>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): [QueryKey, TData | undefined][] {\n    const arg1Unreffed = cloneDeepUnref(queryKeyOrFilters)\n    const arg3Unreffed = cloneDeepUnref(options) as SetDataOptions\n    if (isQueryKey(arg1Unreffed)) {\n      return super.setQueriesData(arg1Unreffed, updater, arg3Unreffed)\n    }\n    return super.setQueriesData(\n      arg1Unreffed as QueryFilters,\n      updater,\n      arg3Unreffed,\n    )\n  }\n\n  getQueryState<TData = unknown, TError = undefined>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): QueryState<TData, TError> | undefined {\n    return super.getQueryState(\n      cloneDeepUnref(queryKey),\n      cloneDeepUnref(filters) as QueryFilters,\n    )\n  }\n\n  removeQueries(filters?: MaybeRefDeep<QueryFilters>): void\n  removeQueries(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n  ): void\n  removeQueries(\n    arg1?: MaybeRefDeep<QueryKey | QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters>,\n  ): void {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.removeQueries(\n        arg1Unreffed,\n        cloneDeepUnref(arg2) as QueryFilters,\n      )\n    }\n    return super.removeQueries(arg1Unreffed as QueryFilters)\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: MaybeRefDeep<ResetQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<ResetQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    arg1?: MaybeRefDeep<QueryKey | ResetQueryFilters<TPageData>>,\n    arg2?: MaybeRefDeep<ResetQueryFilters<TPageData> | ResetOptions>,\n    arg3?: MaybeRefDeep<ResetOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.resetQueries(\n        arg1Unreffed,\n        arg2Unreffed as ResetQueryFilters<TPageData> | undefined,\n        cloneDeepUnref(arg3) as ResetOptions,\n      )\n    }\n    return super.resetQueries(\n      arg1Unreffed as ResetQueryFilters<TPageData>,\n      arg2Unreffed as ResetOptions,\n    )\n  }\n\n  cancelQueries(\n    filters?: MaybeRefDeep<QueryFilters>,\n    options?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void>\n  cancelQueries(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<QueryFilters>,\n    options?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: MaybeRefDeep<QueryKey | QueryFilters>,\n    arg2?: MaybeRefDeep<QueryFilters | CancelOptions>,\n    arg3?: MaybeRefDeep<CancelOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.cancelQueries(\n        arg1Unreffed,\n        arg2Unreffed as QueryFilters | undefined,\n        cloneDeepUnref(arg3) as CancelOptions,\n      )\n    }\n    return super.cancelQueries(\n      arg1Unreffed as QueryFilters,\n      arg2Unreffed as CancelOptions,\n    )\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: MaybeRefDeep<InvalidateQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<InvalidateQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    arg1?: MaybeRefDeep<QueryKey | InvalidateQueryFilters<TPageData>>,\n    arg2?: MaybeRefDeep<InvalidateQueryFilters<TPageData> | InvalidateOptions>,\n    arg3?: MaybeRefDeep<InvalidateOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.invalidateQueries(\n        arg1Unreffed,\n        arg2Unreffed as InvalidateQueryFilters | undefined,\n        cloneDeepUnref(arg3) as InvalidateOptions,\n      )\n    }\n    return super.invalidateQueries(\n      arg1Unreffed as InvalidateQueryFilters<TPageData>,\n      arg2Unreffed as InvalidateOptions,\n    )\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: MaybeRefDeep<RefetchQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: MaybeRefDeep<QueryKey>,\n    filters?: MaybeRefDeep<RefetchQueryFilters<TPageData>>,\n    options?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    arg1?: MaybeRefDeep<QueryKey | RefetchQueryFilters<TPageData>>,\n    arg2?: MaybeRefDeep<RefetchQueryFilters<TPageData> | RefetchOptions>,\n    arg3?: MaybeRefDeep<RefetchOptions>,\n  ): Promise<void> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.refetchQueries(\n        arg1Unreffed,\n        arg2Unreffed as RefetchQueryFilters | undefined,\n        cloneDeepUnref(arg3) as RefetchOptions,\n      )\n    }\n    return super.refetchQueries(\n      arg1Unreffed as RefetchQueryFilters<TPageData>,\n      arg2Unreffed as RefetchOptions,\n    )\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | MaybeRefDeep<TQueryKey>\n      | MaybeRefDeep<FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>>,\n    arg3?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.fetchQuery(\n        arg1Unreffed as TQueryKey,\n        arg2Unreffed as QueryFunction<TQueryFnData, TQueryKey>,\n        cloneDeepUnref(arg3) as FetchQueryOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryKey\n        >,\n      )\n    }\n    return super.fetchQuery(\n      arg1Unreffed as FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    )\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: MaybeRefDeep<\n      TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>>,\n    arg3?: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void> {\n    return super.prefetchQuery(\n      cloneDeepUnref(arg1) as any,\n      cloneDeepUnref(arg2) as any,\n      cloneDeepUnref(arg3) as any,\n    )\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: MaybeRefDeep<\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<\n          FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n        >,\n    arg3?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<InfiniteData<TData>> {\n    const arg1Unreffed = cloneDeepUnref(arg1)\n    const arg2Unreffed = cloneDeepUnref(arg2)\n    if (isQueryKey(arg1Unreffed)) {\n      return super.fetchInfiniteQuery(\n        arg1Unreffed as TQueryKey,\n        arg2Unreffed as QueryFunction<TQueryFnData, TQueryKey>,\n        cloneDeepUnref(arg3) as FetchInfiniteQueryOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryKey\n        >,\n      )\n    }\n    return super.fetchInfiniteQuery(\n      arg1Unreffed as FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey\n      >,\n    )\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: MaybeRefDeep<TQueryKey>,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: MaybeRefDeep<\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | MaybeRefDeep<\n          FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n        >,\n    arg3?: MaybeRefDeep<\n      FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void> {\n    return super.prefetchInfiniteQuery(\n      cloneDeepUnref(arg1) as any,\n      cloneDeepUnref(arg2) as any,\n      cloneDeepUnref(arg3) as any,\n    )\n  }\n\n  setDefaultOptions(options: MaybeRefDeep<DefaultOptions>): void {\n    super.setDefaultOptions(cloneDeepUnref(options) as DefaultOptions)\n  }\n\n  setQueryDefaults(\n    queryKey: MaybeRefDeep<QueryKey>,\n    options: MaybeRefDeep<QueryObserverOptions<any, any, any, any>>,\n  ): void {\n    super.setQueryDefaults(\n      cloneDeepUnref(queryKey),\n      cloneDeepUnref(options) as any,\n    )\n  }\n\n  getQueryDefaults(\n    queryKey?: MaybeRefDeep<QueryKey>,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    return super.getQueryDefaults(cloneDeepUnref(queryKey))\n  }\n\n  setMutationDefaults(\n    mutationKey: MaybeRefDeep<MutationKey>,\n    options: MaybeRefDeep<MutationObserverOptions<any, any, any, any>>,\n  ): void {\n    super.setMutationDefaults(\n      cloneDeepUnref(mutationKey),\n      cloneDeepUnref(options) as any,\n    )\n  }\n\n  getMutationDefaults(\n    mutationKey?: MaybeRefDeep<MutationKey>,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    return super.getMutationDefaults(cloneDeepUnref(mutationKey))\n  }\n}\n","import { parseFilterArgs, parseQueryArgs, functionalUpdate, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs';\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n    this.mountCount = 0;\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\"Passing a custom logger has been deprecated and will be removed in the next major version.\");\n    }\n  }\n\n  mount() {\n    this.mountCount++;\n    if (this.mountCount !== 1) return;\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    this.mountCount--;\n    if (this.mountCount !== 0) return;\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    this.unsubscribeFocus = undefined;\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n    this.unsubscribeOnline = undefined;\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  ensureQueryData(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const cachedData = this.getQueryData(parsedOptions.queryKey);\n    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nexport { QueryClient };\n//# sourceMappingURL=queryClient.mjs.map\n","import { isVue2 } from 'vue-demi'\nimport { isServer } from '@tanstack/query-core'\n\nimport { QueryClient } from './queryClient'\nimport { getClientKey } from './utils'\nimport { setupDevtools } from './devtools/devtools'\nimport type { QueryClientConfig } from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\n\ndeclare global {\n  interface Window {\n    __VUE_QUERY_CONTEXT__?: QueryClient\n  }\n}\n\ntype ClientPersister = (client: QueryClient) => [() => void, Promise<void>]\n\ninterface CommonOptions {\n  queryClientKey?: string\n  contextSharing?: boolean\n  clientPersister?: ClientPersister\n}\n\ninterface ConfigOptions extends CommonOptions {\n  queryClientConfig?: MaybeRefDeep<QueryClientConfig>\n}\n\ninterface ClientOptions extends CommonOptions {\n  queryClient?: QueryClient\n}\n\nexport type VueQueryPluginOptions = ConfigOptions | ClientOptions\n\nexport const VueQueryPlugin = {\n  install: (app: any, options: VueQueryPluginOptions = {}) => {\n    const clientKey = getClientKey(options.queryClientKey)\n    let client: QueryClient\n\n    if ('queryClient' in options && options.queryClient) {\n      client = options.queryClient\n    } else {\n      if (options.contextSharing && typeof window !== 'undefined') {\n        if (!window.__VUE_QUERY_CONTEXT__) {\n          const clientConfig =\n            'queryClientConfig' in options\n              ? options.queryClientConfig\n              : undefined\n          client = new QueryClient(clientConfig)\n          window.__VUE_QUERY_CONTEXT__ = client\n        } else {\n          client = window.__VUE_QUERY_CONTEXT__\n        }\n      } else {\n        const clientConfig =\n          'queryClientConfig' in options ? options.queryClientConfig : undefined\n        client = new QueryClient(clientConfig)\n      }\n    }\n\n    if (!isServer) {\n      client.mount()\n    }\n\n    let persisterUnmount = () => {\n      // noop\n    }\n\n    if (options.clientPersister) {\n      client.isRestoring.value = true\n      const [unmount, promise] = options.clientPersister(client)\n      persisterUnmount = unmount\n      promise.then(() => {\n        client.isRestoring.value = false\n      })\n    }\n\n    if (process.env.NODE_ENV !== 'production' && options.contextSharing) {\n      client\n        .getLogger()\n        .error(\n          `The contextSharing option has been deprecated and will be removed in the next major version`,\n        )\n    }\n\n    const cleanup = () => {\n      client.unmount()\n      persisterUnmount()\n    }\n\n    if (app.onUnmount) {\n      app.onUnmount(cleanup)\n    } else {\n      const originalUnmount = app.unmount\n      app.unmount = function vueQueryUnmount() {\n        cleanup()\n        originalUnmount()\n      }\n    }\n\n    /* istanbul ignore next */\n    if (isVue2) {\n      app.mixin({\n        beforeCreate() {\n          // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L30\n          if (!this._provided) {\n            const provideCache = {}\n            Object.defineProperty(this, '_provided', {\n              get: () => provideCache,\n              set: (v) => Object.assign(provideCache, v),\n            })\n          }\n\n          this._provided[clientKey] = client\n\n          if (process.env.NODE_ENV === 'development') {\n            if (this === this.$root) {\n              setupDevtools(this, client)\n            }\n          }\n        },\n      })\n    } else {\n      app.provide(clientKey, client)\n\n      if (process.env.NODE_ENV === 'development') {\n        setupDevtools(app, client)\n      }\n    }\n  },\n}\n","import {\n  computed,\n  onScopeDispose,\n  reactive,\n  readonly,\n  toRefs,\n  unref,\n  watch,\n} from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, isQueryKey, updateState } from './utils'\nimport type { ToRefs, UnwrapRef } from 'vue-demi'\nimport type {\n  QueryFunction,\n  QueryKey,\n  QueryObserver,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { MaybeRef, WithQueryClientKey } from './types'\nimport type { UseQueryOptions } from './useQuery'\nimport type { UseInfiniteQueryOptions } from './useInfiniteQuery'\n\nexport type UseQueryReturnType<\n  TData,\n  TError,\n  Result = QueryObserverResult<TData, TError>,\n> = ToRefs<Readonly<Result>> & {\n  suspense: () => Promise<Result>\n}\n\ntype UseQueryOptionsGeneric<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> =\n  | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  Observer: typeof QueryObserver,\n  arg1:\n    | TQueryKey\n    | UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey>,\n  arg2:\n    | QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>\n    | UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey> = {},\n  arg3: UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey> = {},\n): UseQueryReturnType<TData, TError> {\n  const options = computed(() => parseQueryArgs(arg1, arg2, arg3))\n\n  const queryClient =\n    options.value.queryClient ?? useQueryClient(options.value.queryClientKey)\n\n  const defaultedOptions = computed(() => {\n    const defaulted = queryClient.defaultQueryOptions(options.value)\n    defaulted._optimisticResults = queryClient.isRestoring.value\n      ? 'isRestoring'\n      : 'optimistic'\n\n    return defaulted\n  })\n\n  const observer = new Observer(queryClient, defaultedOptions.value)\n  const state = reactive(observer.getCurrentResult())\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  watch(\n    queryClient.isRestoring,\n    (isRestoring) => {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isRestoring) {\n        unsubscribe()\n        unsubscribe = observer.subscribe((result) => {\n          updateState(state, result)\n        })\n      }\n    },\n    { immediate: true },\n  )\n\n  watch(\n    defaultedOptions,\n    () => {\n      observer.setOptions(defaultedOptions.value)\n      updateState(state, observer.getCurrentResult())\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  const suspense = () => {\n    return new Promise<QueryObserverResult<TData, TError>>((resolve) => {\n      let stopWatch = () => {\n        //noop\n      }\n      const run = () => {\n        if (defaultedOptions.value.enabled !== false) {\n          const optimisticResult = observer.getOptimisticResult(\n            defaultedOptions.value,\n          )\n          if (optimisticResult.isStale) {\n            stopWatch()\n            resolve(observer.fetchOptimistic(defaultedOptions.value))\n          } else {\n            stopWatch()\n            resolve(optimisticResult)\n          }\n        }\n      }\n\n      run()\n\n      stopWatch = watch(defaultedOptions, run, { deep: true })\n    })\n  }\n\n  return {\n    ...(toRefs(readonly(state)) as UseQueryReturnType<TData, TError>),\n    suspense,\n  }\n}\n\nexport function parseQueryArgs<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | MaybeRef<TQueryKey>\n    | MaybeRef<UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey>>,\n  arg2:\n    | MaybeRef<QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>>\n    | MaybeRef<\n        UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey>\n      > = {},\n  arg3: MaybeRef<\n    UseQueryOptionsGeneric<TQueryFnData, TError, TData, TQueryKey>\n  > = {},\n): WithQueryClientKey<\n  QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n> {\n  const plainArg1 = unref(arg1)\n  const plainArg2 = unref(arg2)\n  const plainArg3 = unref(arg3)\n\n  let options = plainArg1\n\n  if (!isQueryKey(plainArg1)) {\n    options = plainArg1\n  } else if (typeof plainArg2 === 'function') {\n    options = { ...plainArg3, queryKey: plainArg1, queryFn: plainArg2 }\n  } else {\n    options = { ...plainArg2, queryKey: plainArg1 }\n  }\n\n  return cloneDeepUnref(options) as WithQueryClientKey<\n    QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n  >\n}\n","import { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type { UnwrapRef } from 'vue-demi'\nimport type {\n  InfiniteQueryObserverResult,\n  QueryFunction,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\n\nimport type { UseQueryReturnType } from './useBaseQuery'\n\nimport type {\n  DistributiveOmit,\n  VueInfiniteQueryObserverOptions,\n  WithQueryClientKey,\n} from './types'\n\nexport type UseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithQueryClientKey<\n  VueInfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >\n>\n\ntype InfiniteQueryReturnType<TData, TError> = UseQueryReturnType<\n  TData,\n  TError,\n  InfiniteQueryObserverResult<TData, TError>\n>\nexport type UseInfiniteQueryReturnType<TData, TError> = DistributiveOmit<\n  InfiniteQueryReturnType<TData, TError>,\n  'fetchNextPage' | 'fetchPreviousPage' | 'refetch' | 'remove'\n> & {\n  fetchNextPage: InfiniteQueryObserverResult<TData, TError>['fetchNextPage']\n  fetchPreviousPage: InfiniteQueryObserverResult<\n    TData,\n    TError\n  >['fetchPreviousPage']\n  refetch: InfiniteQueryObserverResult<TData, TError>['refetch']\n  remove: InfiniteQueryObserverResult<TData, TError>['remove']\n}\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryReturnType<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>\n    | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseInfiniteQueryReturnType<TData, TError> {\n  const result = useBaseQuery(\n    InfiniteQueryObserver as typeof QueryObserver,\n    arg1,\n    arg2,\n    arg3,\n  ) as InfiniteQueryReturnType<TData, TError>\n  return {\n    ...result,\n    fetchNextPage: result.fetchNextPage.value,\n    fetchPreviousPage: result.fetchPreviousPage.value,\n    refetch: result.refetch.value,\n    remove: result.remove.value,\n  }\n}\n","import { computed, onScopeDispose, ref, unref, watch } from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type { QueryFilters as QF, QueryKey } from '@tanstack/query-core'\n\nimport type { MaybeRef, MaybeRefDeep, WithQueryClientKey } from './types'\n\nexport type QueryFilters = MaybeRefDeep<WithQueryClientKey<QF>>\n\nexport function useIsFetching(filters?: QueryFilters): Ref<number>\nexport function useIsFetching(\n  queryKey?: MaybeRef<QueryKey>,\n  filters?: Omit<QueryFilters, 'queryKey'>,\n): Ref<number>\nexport function useIsFetching(\n  arg1?: MaybeRef<QueryKey> | QueryFilters,\n  arg2?: Omit<QueryFilters, 'queryKey'>,\n): Ref<number> {\n  const filters = computed(() => parseFilterArgs(arg1, arg2))\n  const queryClient =\n    filters.value.queryClient ?? useQueryClient(filters.value.queryClientKey)\n\n  const isFetching = ref(queryClient.isFetching(filters))\n\n  const unsubscribe = queryClient.getQueryCache().subscribe(() => {\n    isFetching.value = queryClient.isFetching(filters)\n  })\n\n  watch(\n    filters,\n    () => {\n      isFetching.value = queryClient.isFetching(filters)\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return isFetching\n}\n\nexport function parseFilterArgs(\n  arg1?: MaybeRef<QueryKey> | QueryFilters,\n  arg2: QueryFilters = {},\n) {\n  const plainArg1 = unref(arg1)\n  const plainArg2 = unref(arg2)\n\n  let options = plainArg1\n\n  if (isQueryKey(plainArg1)) {\n    options = { ...plainArg2, queryKey: plainArg1 }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    options = plainArg1 || {}\n  }\n\n  return cloneDeepUnref(options) as WithQueryClientKey<QF>\n}\n","import { computed, onScopeDispose, ref, unref, watch } from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, isQueryKey } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type { MutationFilters as MF, MutationKey } from '@tanstack/query-core'\n\nimport type { MaybeRef, MaybeRefDeep, WithQueryClientKey } from './types'\n\nexport type MutationFilters = MaybeRefDeep<WithQueryClientKey<MF>>\n\nexport function useIsMutating(filters?: MutationFilters): Ref<number>\nexport function useIsMutating(\n  mutationKey?: MaybeRef<MutationKey>,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n): Ref<number>\nexport function useIsMutating(\n  arg1?: MaybeRef<MutationKey> | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'>,\n): Ref<number> {\n  const filters = computed(() => parseFilterArgs(arg1, arg2))\n  const queryClient =\n    filters.value.queryClient ?? useQueryClient(filters.value.queryClientKey)\n\n  const isMutating = ref(queryClient.isMutating(filters))\n\n  const unsubscribe = queryClient.getMutationCache().subscribe(() => {\n    isMutating.value = queryClient.isMutating(filters)\n  })\n\n  watch(\n    filters,\n    () => {\n      isMutating.value = queryClient.isMutating(filters)\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return isMutating\n}\n\nexport function parseFilterArgs(\n  arg1?: MaybeRef<MutationKey> | MutationFilters,\n  arg2: MutationFilters = {},\n) {\n  const plainArg1 = unref(arg1)\n  const plainArg2 = unref(arg2)\n\n  let options = plainArg1\n\n  if (isQueryKey(plainArg1)) {\n    options = { ...plainArg2, mutationKey: plainArg1 }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    options = plainArg1 || {}\n  }\n\n  return cloneDeepUnref(options) as WithQueryClientKey<MF>\n}\n","import {\n  computed,\n  onScopeDispose,\n  reactive,\n  readonly,\n  toRefs,\n  unref,\n  watch,\n} from 'vue-demi'\nimport { MutationObserver } from '@tanstack/query-core'\nimport { cloneDeepUnref, isMutationKey, updateState } from './utils'\nimport { useQueryClient } from './useQueryClient'\nimport type { ToRefs } from 'vue-demi'\nimport type {\n  MutateFunction,\n  MutateOptions,\n  MutationFunction,\n  MutationKey,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from '@tanstack/query-core'\nimport type {\n  DistributiveOmit,\n  MaybeRef,\n  MaybeRefDeep,\n  WithQueryClientKey,\n} from './types'\n\ntype MutationResult<TData, TError, TVariables, TContext> = DistributiveOmit<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  'mutate' | 'reset'\n>\n\nexport type UseMutationOptions<TData, TError, TVariables, TContext> =\n  WithQueryClientKey<\n    MutationObserverOptions<TData, TError, TVariables, TContext>\n  >\n\nexport type VueMutationObserverOptions<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = {\n  [Property in keyof UseMutationOptions<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >]: MaybeRefDeep<\n    UseMutationOptions<TData, TError, TVariables, TContext>[Property]\n  >\n}\n\ntype MutateSyncFunction<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...options: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\nexport type UseMutationReturnType<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n  Result = MutationResult<TData, TError, TVariables, TContext>,\n> = ToRefs<Readonly<Result>> & {\n  mutate: MutateSyncFunction<TData, TError, TVariables, TContext>\n  mutateAsync: MutateFunction<TData, TError, TVariables, TContext>\n  reset: MutationObserverResult<TData, TError, TVariables, TContext>['reset']\n}\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MaybeRef<MutationFunction<TData, TVariables>>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationFn'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MaybeRef<MutationKey>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MaybeRef<MutationKey>,\n  mutationFn?: MaybeRef<MutationFunction<TData, TVariables>>,\n  options?: MaybeRef<\n    Omit<\n      VueMutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey' | 'mutationFn'\n    >\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MaybeRef<MutationKey>\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg2?:\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg3?: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): UseMutationReturnType<TData, TError, TVariables, TContext> {\n  const options = computed(() => {\n    return parseMutationArgs(arg1, arg2, arg3)\n  })\n  const queryClient =\n    options.value.queryClient ?? useQueryClient(options.value.queryClientKey)\n  const observer = new MutationObserver(\n    queryClient,\n    queryClient.defaultMutationOptions(options.value),\n  )\n  const state = reactive(observer.getCurrentResult())\n\n  const unsubscribe = observer.subscribe((result) => {\n    updateState(state, result)\n  })\n\n  const mutate = (\n    variables: TVariables,\n    mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>,\n  ) => {\n    observer.mutate(variables, mutateOptions).catch(() => {\n      // This is intentional\n    })\n  }\n\n  watch(\n    options,\n    () => {\n      observer.setOptions(queryClient.defaultMutationOptions(options.value))\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  const resultRefs = toRefs(readonly(state)) as unknown as ToRefs<\n    Readonly<MutationResult<TData, TError, TVariables, TContext>>\n  >\n\n  return {\n    ...resultRefs,\n    mutate,\n    mutateAsync: state.mutate,\n    reset: state.reset,\n  }\n}\n\nexport function parseMutationArgs<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MaybeRef<MutationKey>\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg2?:\n    | MaybeRef<MutationFunction<TData, TVariables>>\n    | MaybeRef<VueMutationObserverOptions<TData, TError, TVariables, TContext>>,\n  arg3?: MaybeRef<\n    VueMutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n): WithQueryClientKey<\n  MutationObserverOptions<TData, TError, TVariables, TContext>\n> {\n  const plainArg1 = unref(arg1)\n  const plainArg2 = unref(arg2)\n  let options = plainArg1\n  if (isMutationKey(plainArg1)) {\n    if (typeof plainArg2 === 'function') {\n      const plainArg3 = unref(arg3)\n      options = { ...plainArg3, mutationKey: plainArg1, mutationFn: plainArg2 }\n    } else {\n      options = { ...plainArg2, mutationKey: plainArg1 }\n    }\n  }\n\n  if (typeof plainArg1 === 'function') {\n    options = { ...plainArg2, mutationFn: plainArg1 }\n  }\n\n  return cloneDeepUnref(options) as UseMutationOptions<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { QueriesObserver } from '@tanstack/query-core'\nimport { computed, onScopeDispose, reactive, readonly, watch } from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\n\nimport type { QueryFunction, QueryObserverResult } from '@tanstack/query-core'\n\nimport type { UseQueryOptions } from './useQuery'\nimport type { QueryClient } from './queryClient'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptions<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptions<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptions<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptions<TQueryFnData, unknown, TQueryFnData, TQueryKey>\n    : // Fallback\n      UseQueryOptions\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? QueryObserverResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? QueryObserverResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? QueryObserverResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? QueryObserverResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? QueryObserverResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? QueryObserverResult<TQueryFnData>\n    : // Fallback\n      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptions[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptions[]\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? QueryObserverResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    QueryObserverResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    QueryObserverResult[]\n\ntype UseQueriesOptionsArg<T extends any[]> = readonly [...UseQueriesOptions<T>]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  queryClient: queryClientInjected,\n}: {\n  queries: Ref<UseQueriesOptionsArg<T>> | UseQueriesOptionsArg<T>\n  queryClient?: QueryClient\n}): Readonly<UseQueriesResults<T>> {\n  const unreffedQueries = computed(\n    () => cloneDeepUnref(queries) as UseQueriesOptionsArg<T>,\n  )\n\n  const queryClientKey = unreffedQueries.value[0]?.queryClientKey\n  const optionsQueryClient = unreffedQueries.value[0]?.queryClient as\n    | QueryClient\n    | undefined\n  const queryClient =\n    queryClientInjected ?? optionsQueryClient ?? useQueryClient(queryClientKey)\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    (queryClientKey || optionsQueryClient)\n  ) {\n    queryClient\n      .getLogger()\n      .error(\n        `Providing queryClient to individual queries in useQueries has been deprecated and will be removed in the next major version. You can still pass queryClient as an option directly to useQueries hook.`,\n      )\n  }\n\n  const defaultedQueries = computed(() =>\n    unreffedQueries.value.map((options) => {\n      const defaulted = queryClient.defaultQueryOptions(options)\n      defaulted._optimisticResults = queryClient.isRestoring.value\n        ? 'isRestoring'\n        : 'optimistic'\n\n      return defaulted\n    }),\n  )\n\n  const observer = new QueriesObserver(queryClient, defaultedQueries.value)\n  const state = reactive(observer.getCurrentResult())\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  watch(\n    queryClient.isRestoring,\n    (isRestoring) => {\n      if (!isRestoring) {\n        unsubscribe()\n        unsubscribe = observer.subscribe((result) => {\n          state.splice(0, result.length, ...result)\n        })\n        // Subscription would not fire for persisted results\n        state.splice(\n          0,\n          state.length,\n          ...observer.getOptimisticResult(defaultedQueries.value),\n        )\n      }\n    },\n    { immediate: true },\n  )\n\n  watch(\n    unreffedQueries,\n    () => {\n      observer.setQueries(defaultedQueries.value)\n      state.splice(0, state.length, ...observer.getCurrentResult())\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return readonly(state) as UseQueriesResults<T>\n}\n","import { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type { ToRefs, UnwrapRef } from 'vue-demi'\nimport type {\n  DefinedQueryObserverResult,\n  QueryFunction,\n  QueryKey,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseQueryReturnType as UQRT } from './useBaseQuery'\nimport type {\n  DistributiveOmit,\n  VueQueryObserverOptions,\n  WithQueryClientKey,\n} from './types'\n\nexport type UseQueryReturnType<TData, TError> = DistributiveOmit<\n  UQRT<TData, TError>,\n  'refetch' | 'remove'\n> & {\n  refetch: QueryObserverResult<TData, TError>['refetch']\n  remove: QueryObserverResult<TData, TError>['remove']\n}\n\nexport type UseQueryDefinedReturnType<TData, TError> = DistributiveOmit<\n  ToRefs<Readonly<DefinedQueryObserverResult<TData, TError>>>,\n  'refetch' | 'remove'\n> & {\n  suspense: () => Promise<QueryObserverResult<TData, TError>>\n  refetch: QueryObserverResult<TData, TError>['refetch']\n  remove: QueryObserverResult<TData, TError>['remove']\n}\n\nexport type UseQueryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithQueryClientKey<\n  VueQueryObserverOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>\n>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, UnwrapRef<TQueryKey>>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n):\n  | UseQueryReturnType<TData, TError>\n  | UseQueryDefinedReturnType<TData, TError> {\n  const result = useBaseQuery(QueryObserver, arg1, arg2, arg3)\n\n  return {\n    ...result,\n    refetch: result.refetch.value,\n    remove: result.remove.value,\n  }\n}\n"],"names":["Subscribable","constructor","this","listeners","Set","subscribe","bind","listener","identity","add","onSubscribe","delete","onUnsubscribe","hasListeners","size","isServer","window","noop","isValidTimeout","value","Infinity","difference","array1","array2","filter","x","includes","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","mutationKey","hashQueryKey","status","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","array","isPlainArray","aSize","length","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","isDataEqual","structuralSharing","focusManager","super","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","undefined","_this$cleanup2","focused","setFocused","forEach","isFocused","document","visibilityState","onlineEvents","onlineManager","onOnline","event","online","setOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","onSuccess","reject","onError","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","defaultLogger","console","notifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","push","flush","originalQueue","batch","batchCalls","args","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","newCacheTime","clearTimeout","Query","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","getDefaultState","meta","remove","setData","newData","dispatch","manual","setState","setStateOptions","_this$retryer","retryer","reset","observer","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","AbortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","_context$fetchOptions2","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","onSettled","isFetchingOptimistic","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","Error","action","_action$meta","_action$dataUpdatedAt","reducer","onQueryUpdate","QueryCache","queries","queriesMap","build","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","queryInMap","clear","getAll","findAll","Mutation","mutationId","mutationCache","_this$retryer$continu","execute","async","executeMutation","_this$options$retry","mutationFn","variables","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","onMutate","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","failureReason","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","_this$resuming","resuming","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryObserver","trackedProps","selectError","bindMethods","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","getQueryCache","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","optimisticResult","keepPreviousData","placeholderData","isPlaceholderData","shouldAssignObserverCurrentProperties","currentResult","currentResultOptions","currentResultState","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","defaultedOptions","_fetchOptions$cancelR","throwOnError","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","_optimisticResults","fetchOnMount","fetchOptionally","isSuccess","select","selectFn","selectResult","isFetching","isLoading","isError","isInitialLoading","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","useErrorBoundary","typedKey","has","shouldNotifyListeners","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","QueriesObserver","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","map","newObserversMap","fromEntries","newResult","hasIndexChange","index","getQueries","getObservers","prevObserversMap","Map","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","matchingObserversSet","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","concat","indexOf","slice","replaceAt","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","_state$data","_state$data2","MutationObserver","mutate","_this$currentMutation","getMutationCache","currentMutation","_this$currentMutation2","mutateOptions","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","VUE_QUERY_CLIENT","getClientKey","updateState","update","cloneDeep","customizer","isRef","getPrototypeOf","entries","cloneDeepUnref","obj","unref","useQueryClient","id","_getCurrentInstance","getCurrentInstance","proxy","queryClient","inject","QC","arg1Unreffed","arg2Unreffed","MC","QueryClient","queryCache","queryDefaults","mutationDefaults","mountCount","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isMutating","getQueryData","_this$queryCache$find","ensureQueryData","parsedOptions","cachedData","fetchQuery","getQueriesData","queryKeyOrFilters","setQueryData","updater","input","functionalUpdate","setQueriesData","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","all","invalidateQueries","_ref","_filters$refetchType","refetchType","_options$cancelRefetc","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","firstMatchingDefaults","setMutationDefaults","_defaulted","unreffedConfig","isRestoring","ref","unreffed","arg3Unreffed","VueQueryPlugin","install","app","clientKey","queryClientKey","contextSharing","__VUE_QUERY_CONTEXT__","clientConfig","queryClientConfig","persisterUnmount","clientPersister","onUnmount","originalUnmount","isVue2","mixin","beforeCreate","_provided","provideCache","set","v","assign","provide","useBaseQuery","Observer","_options$value$queryC","computed","plainArg1","plainArg2","plainArg3","defaulted","reactive","unsubscribe","watch","immediate","deep","onScopeDispose","toRefs","readonly","stopWatch","dehydrateMutations","shouldDehydrateMutation","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery","dehydratedState","dehydratedMutation","_options$defaultOptio","dehydratedQuery","_options$defaultOptio2","dehydratedQueryState","_filters$value$queryC","parseMutationArgs","mutateAsync","queryClientInjected","_unreffedQueries$valu","_unreffedQueries$valu2","unreffedQueries","optionsQueryClient","defaultedQueries","splice"],"mappings":"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"}